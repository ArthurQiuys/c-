1.this指针：
    是一个常量指针（不可以被修改，一切企图修改该指针的操作都是非法的）
    该指针指向当前对象，也就是当前对象的首地址，
    可以通过该指针去访问当前对象的成员对象和成员函数。
    这个指针只能在成员函数中使用，其他地方都是非法的。
    只有在对象被创建后才能有意义，也就是说不能够在static函数中使用。
    其实他是做为一个函数的参数隐式传达的，不出现在参数列表中，
    调用成员函数的时候，会自动获取当前对象的地址，赋值给this，完成传递，不需要用户的干预。
    他作为一个隐式参数，本质只是一个函数的局部变量，所以不会占用对象的内存。
    只有在发生成员函数的调用时才会对this进行赋值。当成员函数结束时，自动销毁。
    因此，他作为一个函数的参数，表示对象的首地址，只有在函数内部能够使用，也只有在函数
    被实例化之后才有意义。
    （在《C++函数编译原理和成员函数的实现》一节中讲到，成
    员函数最终被编译成与对象无关的普通函数，除了成员变量，会丢失所有信息，
    所以编译时要在成员函数中添加一个额外的参数，把当前对象的首地址传入，
    以此来关联成员函数和成员变量。）这个就是this指针。
2.static数据成员：
    静态成员是属于整个类的而不是某个对象，静态成员变量只存储一份供所有对象共用。
    所以在所有对象中都可以共享它。使用静态成员变量实现多个对象之间的数据共享不会破坏隐藏的原则，保
    证了安全性还可以节省内存。
    因为静态成员函数属于整个类，在类实例化对象之前就已经分配了空间了，而类的非静态成员就
    必须在类实例化之后才会有内存空间。所以调用的时候要注意区分。
3.复制构造函数和赋值运算符重载。
    复制构造函数是一个对象实例化时才会被调用，就是在复制构造函数调用期间，这个对象一直处在
    一个未被定义的状态知道他被复制构造之后，也就是说只要出现一个对象被调用且未被定义时，
    就会调用复制构造函数。其次复制构造函数没有任何返回值，
    赋值运算符重载，是在一个现存的对象被赋予新的值得时候被调用，
    就是两个对象都是已经被初始化，要进行新的赋值的时候才会调用。而且这个有返回值。
4.实现：string1.cc
